{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Bundle Data Models",
        "description": "Implement Bundle struct and related data models for the LinkDing bundles API following the same pattern as existing BookmarkCreate/BookmarkUpdate.",
        "details": "Create `internal/models/bundle.go` with the following structs:\n\n1. **Bundle** — Represents a complete bundle response from the API with all fields:\n   - id (int): Bundle identifier\n   - name (string): Bundle name\n   - search (string): Search terms filter\n   - any_tags (string): Space-separated tags (match any)\n   - all_tags (string): Space-separated tags (match all)\n   - excluded_tags (string): Space-separated tags to exclude\n   - order (int): Display order\n   - date_created (time.Time): Creation timestamp\n   - date_modified (time.Time): Last modification timestamp\n\n2. **BundleCreate** — Request struct for POST /api/bundles/ with omitempty tags for all non-ID fields (name is required but has no omitempty since it's provided positionally)\n\n3. **BundleUpdate** — Request struct for PATCH /api/bundles/<id>/ using pointer fields (*string, *int) to properly implement PATCH semantics (only send provided fields). Include optional fields: name, search, any_tags, all_tags, excluded_tags, order\n\n4. **BundleList** — Paginated response wrapper matching the bookmark pattern:\n   - count (int): Total number of bundles\n   - next (*string): Next page URL pointer\n   - previous (*string): Previous page URL pointer\n   - results ([]Bundle): Page of bundle results\n\nAll structs must use JSON tags matching LinkDing API field names exactly (snake_case). Follow the exact pattern from bookmark.go for consistency.",
        "testStrategy": "Unit tests verifying:\n1. JSON marshaling/unmarshaling for all structs\n2. Pointer fields in BundleUpdate correctly handle nil values (omitted from JSON)\n3. BundleList pagination fields work correctly\n4. Date parsing works for time.Time fields (ISO 8601 format from API)\nUse table-driven tests to validate different field combinations.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Bundle API Client Methods - Read Operations",
        "description": "Add GetBundles (paginated fetch) and GetBundle (single fetch) methods to the API client following existing pagination patterns.",
        "details": "Add to `internal/api/client.go`:\n\n1. **GetBundles(limit, offset int)** — Retrieves a single page of bundles:\n   - Takes limit and offset parameters\n   - Constructs query parameters (limit, offset) via url.Values\n   - Makes GET request to /api/bundles/\n   - Returns *models.BundleList\n   - Follow the exact pattern from GetTags/GetBookmarks\n\n2. **FetchAllBundles()** — Retrieves all bundles with automatic pagination:\n   - Uses GetBundles internally with limit=100 and progressive offsets\n   - Loop continues while Next pointer is non-nil and Results has items\n   - Aggregates all results into []models.Bundle\n   - Returns []models.Bundle and error\n   - Follow the exact pattern from FetchAllTags/FetchAllBookmarks\n\n3. **GetBundle(id int)** — Retrieves a single bundle by ID:\n   - Takes bundle ID parameter\n   - Makes GET request to /api/bundles/<id>/\n   - Returns *models.Bundle\n   - Checks for HTTP 404 and returns user-friendly \"bundle with ID X not found\" error\n   - Follow the exact pattern from GetBookmark\n\nAll methods must:\n- Use c.doRequest() for HTTP operations\n- Defer response body close\n- Use c.decodeResponse() with http.StatusOK\n- Handle errors consistently with existing methods",
        "testStrategy": "Unit tests with httptest.NewServer:\n1. GetBundles with various limit/offset combinations\n2. GetBundles with empty results\n3. FetchAllBundles across multiple pages (3+ pages)\n4. FetchAllBundles with single page\n5. GetBundle success case\n6. GetBundle with 404 returns proper error message\n7. Connection errors (cannot reach server)\n8. JSON decode errors (invalid response body)\nValidate pagination loop termination conditions.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Bundle API Client Methods - Write Operations",
        "description": "Add CreateBundle, UpdateBundle, and DeleteBundle methods to the API client following existing CRUD patterns.",
        "details": "Add to `internal/api/client.go`:\n\n1. **CreateBundle(bundle *models.BundleCreate)** — Creates a new bundle:\n   - Takes BundleCreate struct pointer\n   - Makes POST request to /api/bundles/\n   - Expects HTTP 201 Created response\n   - Returns *models.Bundle (created bundle with ID assigned by server)\n   - Follow the exact pattern from CreateBookmark\n\n2. **UpdateBundle(id int, update *models.BundleUpdate)** — Updates an existing bundle:\n   - Takes bundle ID and BundleUpdate struct pointer\n   - Makes PATCH request to /api/bundles/<id>/\n   - Pointer fields in BundleUpdate ensure only provided fields sent\n   - Checks for HTTP 404 and returns user-friendly error\n   - Returns *models.Bundle (updated bundle)\n   - Expects HTTP 200 OK response\n   - Follow the exact pattern from UpdateBookmark\n\n3. **DeleteBundle(id int)** — Deletes a bundle:\n   - Takes bundle ID parameter\n   - Makes DELETE request to /api/bundles/<id>/\n   - Checks for HTTP 404 and returns user-friendly error\n   - Expects HTTP 204 No Content\n   - Returns error or nil\n   - Follow the exact pattern from DeleteBookmark\n\nAll methods must:\n- Use c.doRequest() with appropriate HTTP method\n- Defer response body close\n- Use c.decodeResponse() with correct expected status code\n- Handle 404 errors with clear \"bundle with ID X not found\" message\n- Follow error handling patterns from existing bookmark methods",
        "testStrategy": "Unit tests with httptest.NewServer:\n1. CreateBundle success (verify HTTP 201, returned ID assigned)\n2. CreateBundle with invalid data (HTTP 400 validation error)\n3. UpdateBundle success (verify PATCH sent with only provided fields)\n4. UpdateBundle with 404 returns proper error\n5. UpdateBundle with single field vs multiple fields\n6. DeleteBundle success (HTTP 204 No Content)\n7. DeleteBundle with 404 returns proper error\n8. Verify request bodies are correctly JSON-encoded\n9. Verify Authorization header present on all requests\nValidate PATCH semantics by checking JSON doesn't include null fields.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Bundle API Client Tests",
        "description": "Create comprehensive unit tests for all bundle API methods in the api package test file.",
        "details": "Add tests to `internal/api/client_test.go` covering all 6 bundle methods:\n\n**Read Operations:**\n- TestGetBundles: Verify correct endpoint, query parameters, response parsing\n- TestGetBundles_Pagination: Test with multiple pages\n- TestFetchAllBundles: Verify aggregates multiple pages correctly\n- TestGetBundle: Success case with valid ID\n- TestGetBundle_NotFound: HTTP 404 returns proper error message\n\n**Write Operations:**\n- TestCreateBundle: Verify POST, correct status code (201), returns created bundle with ID\n- TestCreateBundle_Error: HTTP 400 bad request handling\n- TestUpdateBundle: Verify PATCH, only provided fields in request body\n- TestUpdateBundle_NotFound: HTTP 404 returns proper error\n- TestDeleteBundle: Verify DELETE, HTTP 204 handling\n- TestDeleteBundle_NotFound: HTTP 404 returns proper error\n\n**Common:**\n- All tests use httptest.NewServer\n- Mock servers return valid Bundle JSON responses\n- Verify Authorization header and Content-Type headers\n- Test error responses (bad JSON, network errors)\n\nFollow the patterns established in pagination_test.go for pagination testing and client_test.go for general method testing.",
        "testStrategy": "Implement comprehensive tests:\n1. Mock server responses that match API specification\n2. Validate request methods, paths, headers, bodies\n3. Test all success paths and error cases\n4. Verify pagination loop logic\n5. Ensure 70%+ coverage of bundle methods\n6. Run tests with `go test -v ./internal/api -run TestBundle` to verify",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Bundle Commands Parent Structure",
        "description": "Create the bundles command parent and register it with the root command, following the structure of existing commands like tags.",
        "details": "Create `cmd/linkdingctl/bundles.go` with:\n\n1. **bundlesCmd** — Parent command:\n   - Use: \"bundles\"\n   - Short: \"Manage LinkDing bundles\"\n   - Long: Descriptive help text explaining bundles are saved search/filter configurations\n   - No RunE (parent commands don't execute directly)\n\n2. **init() function**:\n   - Add bundlesCmd to rootCmd with rootCmd.AddCommand(bundlesCmd)\n   - Add subcommands: list, get, create, update, delete\n   - Register all subcommands: bundlesCmd.AddCommand(bundlesListCmd, bundlesGetCmd, etc.)\n\n3. **Global variables for flags**:\n   - bundlesSearch (string): \"--search\" flag\n   - bundlesAnyTags (string): \"--any-tags\" flag\n   - bundlesAllTags (string): \"--all-tags\" flag\n   - bundlesExcludedTags (string): \"--excluded-tags\" flag\n   - bundlesOrder (int): \"--order\" flag (optional, auto-assigned if not provided)\n   - bundlesName (string): \"--name\" flag (for update command only)\n\nStructure should match the tags.go pattern exactly:\n- Define parent command\n- Define subcommands (create empty stubs for now)\n- Define global flag variables\n- Register everything in init()\n\nAll string flags default to empty string, order flag defaults to -1 (indicates not provided).",
        "testStrategy": "Basic structural validation:\n1. Verify bundlesCmd exists and is registered with rootCmd\n2. Test `linkdingctl bundles --help` works\n3. Verify all 5 subcommands are registered\n4. Check flags are properly defined\nDetailed tests come in subsequent command implementation tasks.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Bundles List Command",
        "description": "Implement the `linkdingctl bundles list` command to fetch and display all bundles.",
        "details": "In `cmd/linkdingctl/bundles.go`, implement:\n\n**bundlesListCmd**:\n- Use: \"list\"\n- Short: \"List all bundles\"\n- Long: Multi-line help explaining the list command fetches all bundles\n- RunE: runBundlesList\n\n**runBundlesList function**:\n1. Load config using loadConfig() (handles --url, --token overrides)\n2. Create API client with cfg.URL and cfg.Token\n3. Call client.FetchAllBundles()\n4. Check global jsonOutput flag:\n   - If true: use outputJSON() to return bundles array as JSON\n   - If false: use outputTable() to display as human-readable table\n5. Return error if any step fails\n\n**Table output** (when --json not used):\n- Use text/tabwriter like list.go and tags.go\n- Columns: ID, Name, Search, Order\n- Right-align numeric columns (ID, Order)\n- Truncate Search column if too long\n\n**JSON output** (when --json used):\n- Return the []Bundle array as JSON\n- Should be valid JSON matching API response format\n\nFollow the exact pattern from list.go and tags.go for consistency.\n\nRegister with: bundlesCmd.AddCommand(bundlesListCmd) in init()",
        "testStrategy": "Unit tests in commands_test.go:\n1. Test with mock HTTP server returning multiple bundles\n2. Test table output format (verify column headers, data)\n3. Test --json flag produces valid JSON\n4. Test with empty bundle list\n5. Test error handling (connection error, invalid JSON response)\n6. Test --url and --token flag overrides work\n7. Test pagination (simulated by mock returning large dataset)\nValidate output matches specification format exactly.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Bundles Get Command",
        "description": "Implement the `linkdingctl bundles get <id>` command to retrieve and display a single bundle.",
        "details": "In `cmd/linkdingctl/bundles.go`, implement:\n\n**bundlesGetCmd**:\n- Use: \"get\"\n- Short: \"Get bundle details\"\n- Long: Multi-line help explaining the get command fetches a single bundle by ID\n- Args: cobra.ExactArgs(1) to require exactly one argument (the bundle ID)\n- RunE: runBundlesGet\n\n**runBundlesGet function**:\n1. Parse bundle ID from args[0] (convert string to int)\n2. Load config using loadConfig()\n3. Create API client\n4. Call client.GetBundle(id)\n5. Check global jsonOutput flag:\n   - If true: use outputJSON() to return bundle as JSON object\n   - If false: format as key-value pairs (human-readable)\n6. Return error if bundle not found or other API error\n\n**Human-readable output format** (matching spec):\n```\nID:            <id>\nName:          <name>\nSearch:        <search>\nAny Tags:      <any_tags>\nAll Tags:      <all_tags>\nExcluded Tags: <excluded_tags>\nOrder:         <order>\nCreated:       <date_created formatted as YYYY-MM-DD>\nModified:      <date_modified formatted as YYYY-MM-DD>\n```\n\n**JSON output**:\n- Return single Bundle object as JSON (not an array)\n\nHandle ID parsing errors with clear message (\"invalid bundle ID: <value>\").\n\nRegister with: bundlesCmd.AddCommand(bundlesGetCmd) in init()",
        "testStrategy": "Unit tests in commands_test.go:\n1. Test with valid bundle ID (successful retrieval)\n2. Test with non-existent bundle ID (404 error)\n3. Test human-readable output format matches spec\n4. Test --json flag produces valid JSON\n5. Test invalid ID argument (non-numeric)\n6. Test missing ID argument\n7. Test error handling for connection failures\n8. Test date formatting (YYYY-MM-DD)\n9. Test with empty optional fields (any_tags, all_tags, etc.)\nValidate output format exactly matches specification.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Bundles Create Command",
        "description": "Implement the `linkdingctl bundles create <name> [flags]` command to create new bundles.",
        "details": "In `cmd/linkdingctl/bundles.go`, implement:\n\n**bundlesCreateCmd**:\n- Use: \"create\"\n- Short: \"Create a new bundle\"\n- Long: Multi-line help explaining required name and optional filter flags\n- Args: cobra.ExactArgs(1) to require bundle name as positional argument\n- RunE: runBundlesCreate\n- Flags (defined in init):\n  - --search: Optional search terms\n  - --any-tags: Optional space-separated tags (OR logic)\n  - --all-tags: Optional space-separated tags (AND logic)\n  - --excluded-tags: Optional space-separated tags to exclude\n  - --order: Optional display order (integer)\n\n**runBundlesCreate function**:\n1. Extract bundle name from args[0]\n2. Validate name is not empty (should be guaranteed by args, but verify)\n3. Load config using loadConfig()\n4. Create API client\n5. Build BundleCreate struct with:\n   - name: from args[0]\n   - search: from bundlesSearch flag if provided\n   - any_tags: from bundlesAnyTags flag if provided\n   - all_tags: from bundlesAllTags flag if provided\n   - excluded_tags: from bundlesExcludedTags flag if provided\n   - order: from bundlesOrder flag if cmd.Flags().Changed(\"order\") is true\n6. Call client.CreateBundle(bundleCreate)\n7. Output success message with created bundle info\n8. Check --json flag:\n   - If true: return created bundle as JSON\n   - If false: return human-readable message with ID\n\n**Human-readable output**:\n```\nBundle created: <name>\n  ID: <id>\n```\n\n**JSON output**:\n- Return the full created Bundle object\n\nRegister with: bundlesCmd.AddCommand(bundlesCreateCmd) in init()\n\nImportant: Order field should only be sent to API if explicitly provided (use cmd.Flags().Changed(\"order\")).",
        "testStrategy": "Unit tests in commands_test.go:\n1. Test creating bundle with name only\n2. Test creating bundle with all flags provided\n3. Test creating bundle with partial flags (search and any-tags only)\n4. Test missing name argument\n5. Test output message format\n6. Test --json flag produces valid JSON with ID\n7. Test validation errors from API (duplicate name, etc.)\n8. Test --url and --token overrides\n9. Verify order field only sent when flag provided\n10. Test various tag combinations\nValidate created bundle info matches request and returned ID is valid.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Bundles Update Command",
        "description": "Implement the `linkdingctl bundles update <id> [flags]` command to modify existing bundles.",
        "details": "In `cmd/linkdingctl/bundles.go`, implement:\n\n**bundlesUpdateCmd**:\n- Use: \"update\"\n- Short: \"Update a bundle\"\n- Long: Multi-line help explaining ID is required and at least one flag should be provided\n- Args: cobra.ExactArgs(1) to require bundle ID as positional argument\n- RunE: runBundlesUpdate\n- Flags (defined in init):\n  - --name: Optional new name\n  - --search: Optional search terms\n  - --any-tags: Optional space-separated tags (OR logic)\n  - --all-tags: Optional space-separated tags (AND logic)\n  - --excluded-tags: Optional space-separated tags to exclude\n  - --order: Optional display order\n\n**runBundlesUpdate function**:\n1. Parse bundle ID from args[0] (convert to int)\n2. Load config using loadConfig()\n3. Create API client\n4. Build BundleUpdate struct with pointer fields:\n   - Only populate fields that were explicitly provided via flags\n   - Use cmd.Flags().Changed(\"fieldname\") to check if flag was provided\n   - Example: if cmd.Flags().Changed(\"name\") { bundleUpdate.Name = &bundlesName }\n5. Call client.UpdateBundle(id, bundleUpdate)\n6. Output success message or return updated bundle\n7. Check --json flag:\n   - If true: return updated bundle as JSON\n   - If false: return human-readable message\n\n**Human-readable output**:\n```\nBundle updated: <name> (ID: <id>)\n```\n\n**JSON output**:\n- Return the full updated Bundle object\n\n**Important PATCH semantics**:\n- Only fields explicitly provided should be sent to API\n- Use pointer fields and cmd.Flags().Changed() to implement this\n- This ensures users can update subset of fields without overwriting others\n\nRegister with: bundlesCmd.AddCommand(bundlesUpdateCmd) in init()\n\nValidate ID before API call with clear error message (\"invalid bundle ID: <value>\").",
        "testStrategy": "Unit tests in commands_test.go:\n1. Test updating single field (name only)\n2. Test updating multiple fields\n3. Test updating with all fields\n4. Test PATCH semantics (verify unspecified fields not sent in JSON)\n5. Test missing ID argument\n6. Test invalid ID (non-numeric)\n7. Test non-existent bundle (404 error)\n8. Test --json flag output\n9. Test validation errors from API\n10. Test --url and --token overrides\nValidate only provided fields are sent in PATCH request body (no null values).",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Bundles Delete Command",
        "description": "Implement the `linkdingctl bundles delete <id>` command to remove bundles.",
        "details": "In `cmd/linkdingctl/bundles.go`, implement:\n\n**bundlesDeleteCmd**:\n- Use: \"delete\"\n- Short: \"Delete a bundle\"\n- Long: Multi-line help explaining the delete operation\n- Args: cobra.ExactArgs(1) to require bundle ID as positional argument\n- RunE: runBundlesDelete\n- No flags needed for delete\n\n**runBundlesDelete function**:\n1. Parse bundle ID from args[0] (convert string to int)\n2. Load config using loadConfig()\n3. Create API client\n4. Call client.DeleteBundle(id)\n5. Output success message or error\n6. Return nil on success, error on failure\n\n**Human-readable output** (success):\n```\nBundle deleted (ID: <id>)\n```\n\n**Error handling**:\n- If bundle not found (404): Return user-friendly \"bundle with ID X not found\" error\n- If other errors: Return original error from API client\n\n**Note on --json flag**:\n- Delete doesn't return bundle data (HTTP 204 No Content)\n- --json flag is not particularly useful here but should not cause error\n- Simply output success/failure message regardless of flag\n\nRegister with: bundlesCmd.AddCommand(bundlesDeleteCmd) in init()\n\nValidate ID parsing with clear error message for invalid input.",
        "testStrategy": "Unit tests in commands_test.go:\n1. Test successful deletion (HTTP 204)\n2. Test non-existent bundle (404 error)\n3. Test invalid ID argument (non-numeric)\n4. Test missing ID argument\n5. Test error handling for connection failures\n6. Test output message format\n7. Test --url and --token overrides\n8. Verify DELETE HTTP method used\nValidate success message format exactly matches specification.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Add Bundle Command Tests",
        "description": "Create comprehensive integration-style tests for all bundle commands in the commands_test.go file.",
        "details": "Add tests to `cmd/linkdingctl/commands_test.go` covering all bundle commands:\n\n**List Command Tests:**\n- TestBundlesList: Verify table output with multiple bundles\n- TestBundlesList_JSON: Verify --json flag produces valid JSON\n- TestBundlesList_Empty: Handle empty bundle list\n- TestBundlesList_Error: Handle API errors\n\n**Get Command Tests:**\n- TestBundlesGet: Retrieve and display single bundle\n- TestBundlesGet_JSON: Verify --json flag output\n- TestBundlesGet_NotFound: Handle 404 error\n- TestBundlesGet_InvalidID: Handle non-numeric ID\n- TestBundlesGet_MissingID: Handle missing argument\n\n**Create Command Tests:**\n- TestBundlesCreate_Basic: Create with name only\n- TestBundlesCreate_WithFlags: Create with optional flags\n- TestBundlesCreate_JSON: Verify --json output with ID\n- TestBundlesCreate_MissingName: Handle missing name argument\n- TestBundlesCreate_Error: Handle API validation errors\n\n**Update Command Tests:**\n- TestBundlesUpdate_SingleField: Update name only\n- TestBundlesUpdate_MultipleFields: Update multiple fields\n- TestBundlesUpdate_PatchSemantics: Verify only specified fields sent\n- TestBundlesUpdate_JSON: Verify --json output\n- TestBundlesUpdate_NotFound: Handle 404 error\n- TestBundlesUpdate_InvalidID: Handle non-numeric ID\n\n**Delete Command Tests:**\n- TestBundlesDelete: Successful deletion\n- TestBundlesDelete_NotFound: Handle 404 error\n- TestBundlesDelete_InvalidID: Handle non-numeric ID\n- TestBundlesDelete_MissingID: Handle missing argument\n\n**Common Tests:**\n- All tests use mock HTTP servers\n- Test --url and --token flag overrides\n- Test error message clarity\n- Verify global config loading works\n\nFollow patterns from existing command tests (e.g., TestTagsList, TestTagsCreate).",
        "testStrategy": "Comprehensive integration tests:\n1. Mock HTTP server returns realistic Bundle API responses\n2. Validate command output format matches specification\n3. Test all flags and flag combinations\n4. Test error paths (404, 400, connection errors)\n5. Verify exit codes (0 for success, 1 for error)\n6. Test flag precedence (--url, --token overrides)\n7. Run tests with `go test -v ./cmd/linkdingctl -run TestBundles`\n8. Ensure combined test coverage with API tests meets 70% minimum",
        "priority": "high",
        "dependencies": [
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Test Coverage Validation for Bundle Implementation",
        "description": "Ensure all bundle-related code meets the 70% code coverage threshold across models, api, and command packages.",
        "details": "Verify code coverage for bundle implementation:\n\n1. **Run full test suite with coverage**:\n   - Execute: `make cover` from project root\n   - This runs `go test -cover ./...` and validates 70% threshold per package\n\n2. **Expected coverage targets**:\n   - internal/models: 100% (all structs and methods)\n   - internal/api: 80%+ (all client methods for bundles)\n   - cmd/linkdingctl: 80%+ (all bundle commands)\n\n3. **Coverage gaps to address**:\n   - Identify any uncovered code paths\n   - Add tests for edge cases and error handling\n   - Focus on realistic error scenarios (network, validation, not found)\n\n4. **Verification steps**:\n   - Run `go test -coverprofile=coverage.out ./...`\n   - Run `go tool cover -html=coverage.out` to review coverage report\n   - Ensure no unused code paths\n   - Document any deliberately untested code (e.g., panic scenarios)\n\n5. **Fix coverage gaps**:\n   - Add integration tests if certain paths not covered\n   - Add error case tests\n   - Consider adding tests for edge cases in command flag parsing\n\nValidate final coverage meets 70% minimum before completing.",
        "testStrategy": "Coverage validation approach:\n1. Generate coverage report: `go test -coverprofile=coverage.out ./...`\n2. Open HTML report: `go tool cover -html=coverage.out`\n3. Identify gaps in:\n   - Bundle struct handling\n   - API client error paths\n   - Command flag validation\n   - JSON marshaling/unmarshaling\n4. Add targeted tests to increase coverage\n5. Re-run `make cover` to confirm 70% threshold\n6. All existing tests (bookmarks, tags) must continue passing",
        "priority": "high",
        "dependencies": [
          4,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Integration Testing with Mock LinkDing Server",
        "description": "Create end-to-end tests that validate bundle commands work correctly against a simulated LinkDing API server.",
        "details": "Create realistic integration tests in `cmd/linkdingctl/commands_test.go`:\n\n1. **Setup mock server** that simulates LinkDing bundles API:\n   - Return realistic Bundle JSON responses\n   - Implement all 5 endpoints (list, get, create, update, delete)\n   - Simulate pagination for list endpoint\n   - Return proper HTTP status codes (201 for create, 204 for delete, etc.)\n\n2. **Test realistic workflows**:\n   - Create multiple bundles\n   - List and verify all bundles returned\n   - Get individual bundle details\n   - Update bundle with partial fields\n   - Delete bundle\n\n3. **Test error scenarios**:\n   - Request non-existent bundle (404)\n   - Create with invalid data (400)\n   - Update non-existent bundle (404)\n   - Delete non-existent bundle (404)\n   - Network timeouts (simulate with slow server)\n\n4. **Test pagination handling**:\n   - Create test data with 150+ bundles\n   - Verify list command fetches all pages\n   - Verify FetchAllBundles aggregates correctly\n\n5. **Test output consistency**:\n   - Verify table format matches specification\n   - Verify JSON output is valid and matches API response\n   - Verify error messages are user-friendly\n\n6. **Test flag combinations**:\n   - --json with list, get, create, update\n   - --url and --token overrides\n   - Create with various flag combinations\n   - Update with single vs multiple fields\n\nFocus on realistic usage patterns that users would encounter.",
        "testStrategy": "Integration test approach:\n1. Create helper function to start mock LinkDing server\n2. Test complete workflows from start to finish\n3. Verify all output formats match specification\n4. Test all error cases with realistic API responses\n5. Validate pagination handling with 150+ test bundles\n6. Run tests: `go test -v ./cmd/linkdingctl -run TestBundles`\n7. Ensure no flakiness or race conditions\n8. Validate against specification (specs/23-bundles.md)",
        "priority": "medium",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Documentation and Examples",
        "description": "Add user-facing documentation and examples for bundle commands.",
        "details": "Update documentation files:\n\n1. **README.md**:\n   - Add bundles section to command list\n   - Include basic usage examples for each command\n   - Explain bundle concept and use cases\n\n2. **Help text in commands** (already in code):\n   - Ensure each command has clear Long description\n   - Include usage examples in Long text\n   - Document all flags with clear descriptions\n\n3. **Examples section**:\n   - Create bundles\n   - List and filter bundles\n   - Update bundle configuration\n   - Delete bundles\n   - Use --json for scripting\n\n4. **Specification compliance**:\n   - Ensure output examples match specs/23-bundles.md\n   - Document all API endpoints used\n   - Explain PATCH semantics for update\n\n5. **Error examples**:\n   - Show common error messages\n   - Explain how to troubleshoot\n   - Document error exit codes\n\nKeep documentation focused on practical examples users will need.",
        "testStrategy": "Documentation validation:\n1. Verify all examples are executable\n2. Test command help text: `linkdingctl bundles --help`\n3. Test subcommand help: `linkdingctl bundles list --help`\n4. Verify examples match actual command behavior\n5. Check for consistency with other command documentation\n6. Ensure no broken references or incorrect syntax\n7. Review against specification document",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Final Validation and Quality Assurance",
        "description": "Run complete test suite, validate all requirements met, and ensure code quality standards are met.",
        "details": "Complete final validation before release:\n\n1. **Run full test suite**:\n   - Execute: `make check` (runs fmt, vet, test)\n   - Execute: `make cover` (validates 70% coverage threshold)\n   - Verify all tests pass\n   - Verify no linting errors\n\n2. **Validate against PRD requirements**:\n   - [ ] All 5 CRUD operations implemented\n   - [ ] List command shows ID, Name, Search, Order columns\n   - [ ] Get command shows all fields\n   - [ ] Create accepts name and all optional flags\n   - [ ] Update uses PATCH semantics (only specified fields)\n   - [ ] Delete removes bundle\n   - [ ] All commands support --json flag\n   - [ ] All commands support --url, --token overrides\n   - [ ] Pagination handled transparently\n   - [ ] Error messages user-friendly\n\n3. **Validate against specification**:\n   - Cross-reference with specs/23-bundles.md\n   - Verify command syntax matches spec\n   - Verify output format matches examples\n   - Verify API endpoints used correctly\n\n4. **Code quality checks**:\n   - No TODO comments left in code\n   - No debug prints or logging\n   - All error cases handled\n   - Consistent naming and style\n   - Proper error handling throughout\n\n5. **Manual testing** (if real LinkDing available):\n   - Test against real LinkDing instance\n   - Verify all 5 operations work end-to-end\n   - Test error cases with invalid data\n   - Test pagination with real data\n\n6. **Git cleanup**:\n   - Verify no merge conflicts\n   - Clean git history\n   - All changes committed\n   - Ready for PR review\n\nDocument any deviations from requirements with rationale.",
        "testStrategy": "Final QA approach:\n1. Execute full test suite: `make check`\n2. Execute coverage validation: `make cover`\n3. Run bundle-specific tests: `go test -v ./cmd/linkdingctl -run TestBundles`\n4. Check for any remaining TODOs or FIXMEs\n5. Verify against checklist in specs/23-bundles.md\n6. Test against real LinkDing if available\n7. Code review against CLAUDE.md conventions\n8. Final git status check before completion",
        "priority": "high",
        "dependencies": [
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-24T23:51:28.578Z",
      "updated": "2026-01-24T23:51:28.579Z",
      "description": "Tasks for master context"
    }
  }
}